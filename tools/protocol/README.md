# tools/protocol — описание и руководство

# Кратко

Назначение: единый источник истины для сетевого бинарного протокола движка (сервер ↔ клиент ↔ гейтвей), основанный на FlatBuffers.

Что внутри: схема FlatBuffers (messages.fbs), скрипты генерации, правила версионирования, рекомендации по расширению.

# Команды

Генерация: bun run gen:protocol

## Результат генерации

типы и билдеры доступны в packages/net/src/protocol/generated, а удобные кодеки — в packages/net/src/protocol/codec.ts.

# Состав пакета

- schema/messages.fbs — главная схема протокола FlatBuffers. Содержит все публичные сообщения и Envelope.
- scripts/gen.ts - основной скрипт генерации на основе схемы.

# Быстрый старт

1) Установите flatc (FlatBuffers Compiler):

macOS: brew install flatbuffers

Linux: скачайте релиз flatc с GitHub и положите в PATH

Windows: скачайте flatc.exe и добавьте в PATH

2) Сгенерируйте код протокола: bun run gen:protocol

3) Используйте кодеки в runtime

# Структура схемы (messages.fbs)

1) Идентификатор файла: file_identifier "MDE0" — защита от неверного типа сообщения при декодировании.
2) Базовые типы (struct)
3) Служебные сообщения
4) Handshake и сервисная информация
5) Игровой ввод и команды
6) Унивесальный тип расширения
7) Снапшоты мира
8) Конверт Envelope

## Структура типа расширения

Command { type:uint16; payload:[ubyte] } — универсальный расширяемый канал для плагинов. Правила:

Диапазоны type: 0–999 — зарезервировано ядром; 1000–9999 — общие расширения; 10000+ — модули.

payload — произвольный бинарный формат (можно отправлять вложенные FlatBuffers, msgpack, CBOR и т. п.).

## Структура конверта Envelope

union Body { ...other_messages }

Envelope { seq:uint32; sent_at_ms:uint64; body:Body }

seq — номер сообщения (может использоваться отправителем произвольно)

sent_at_ms — время отправки отправителя (ms since epoch, uint64)
  
# Генерация кода

**Команда:** bun run gen:protocol

**Что делает:**

Вызывает flatc для TypeScript, генерирует messages_generated.js и d.ts (если включено) в packages/net/src/protocol/generated


*Не редактируйте сгенерированные файлы вручную!*

# Правила эволюции протокола

### Версионирование

PROTOCOL_MAJOR — меняется при несовместимых изменениях (удаление/переименование полей/таблиц, изменение семантики)

PROTOCOL_MINOR — при обратносовместимых (добавление новых сообщений, полей с дефолтами)

### Совместимость

- Добавляйте новые поля в конец таблиц с безопасными дефолтами
- Не меняйте существующие поля и их типы
- Для экспериментов используйте Command вместо изменений базовой схемы

### Процесс изменения

1) Измените messages.fbs
2) Пересоберите протокол: bun run gen:protocol
3) Обновите кодеки (packages/net/src/protocol/codec.ts): добавьте новые encode*/decode ветки
4) При необходимости обновите PROTOCOL_MAJOR/MINOR
5) Прогоните сборку и тесты

# Рекомендации по моделированию (FlatBuffers)

- Используйте struct для маленьких структур (Vec3f, Quatf, EntityId) — без накладных расходов
- Используйте table для сообщений и энтити-снимков
- Изменяемость: вместо optional полей используйте битовую mask, это уменьшает двусмысленность
- Вектора структур дешевле вектора таблиц
- Для vectors of structs используйте start<Field>Vector/endVector и создавайте элементы в обратном порядке при сборке

### Производительность и ограничения

- Сообщения должны быть как можно компактнее: используйте float32, uint32 и маски изменений

#### Бюджеты сети:
- Размер кадра WebSocket ограничивается на уровне gateway (см. protocolLimits в конфиге)
- Для снапшотов используйте maxEntitiesPerSnapshot и maxBytesPerSnapshot (реализация — на стороне runtime)
- Отправитель обязан не превышать бюджет; при переполнении — обрезайте сущности по приоритету (self → ближние → дальние)

# Расширение через Command (рекомендуемый путь для модулей)

type: uint16 диапазоны:

0–999 — ядро (зарезервировано ядром)

1000–9999 — официальные модули

10000–65535 — кастомные плагины


payload: любые байты. Практичные варианты:
- вложенные FlatBuffers (собственная схема модуля)
- MessagePack/CBOR/Protobuf
- простой фиксированный бинарный формат

### Регистрация обработчиков:

На сервере (world worker) через WorldContext.registerMessage(type, handler)
На стороне gateway можно перехватывать входящие кадры (registerWsHandler) для кастомных команд до передачи в мир

# Расширение схемы (когда нужно менять базовый протокол)

### Добавление нового сообщения:
1) Добавьте table NewMsg в messages.fbs
2) Добавьте в union Body NewMsg
3) Сгенерируйте код (gen:protocol)
4) Добавьте ветку decodeEnvelope в codec.ts
5) При необходимости — функцию encodeNewMsg
6) Обновите PROTOCOL_MINOR (или MAJOR, если breaking)

Добавление поля:
1) Добавляйте в конец таблицы
2) Устанавливайте безопасные дефолты (0, пустые структуры)
3) Изменение/удаление поля — breaking, увеличивайте PROTOCOL_MAJOR

# Безопасность и валидация

Envelope.file_identifier защищает от неверной укладки

Gateway проверяет размеры сообщений (maxWsFrameBytes, maxMessageBytes)

Для неизвестных Body типов — decoder возвращает null (см. decodeEnvelope)

# FAQ

- Можно ли расширять схему из модулей? Да, но это требует общей регенерации протокола и синхронизации версий. Для независимости используйте Command.
- Почему FlatBuffers? Нулевая (почти) аллокация при декодировании, компактность, кросс-языковая совместимость, стабильный бинарный формат.
- Нужно ли квантовать координаты? На первом этапе нет (float32). Позже можно ввести квантование/пакетные дельты для трафика.
